1. 程序的耦合
    *      耦合：程序键的依赖关系
    *          包括
    *              类之间的依赖
    *              方法之间的依赖
   *       解耦：
    *          降低程序间的依赖关系
   *       实际开发中：编译期不依赖，运行时依赖
    *      解耦思路：
    *          第一种：使用反射来创建对象，避免使用new关键字；
    *          第二种：通过读取配置文件来获取要创建的对象全限定类名。
    */

2. spring 环境搭建：
    2.1 pom.xml 导入jar坐标
    2.2 配置文件的编写： bean.xml
    2.3 spring对bean的管理细节
        2.3.1 创建bean的三种方式：
            2.3.1.1 创建的方式一： 默认方式， bean标签，配以id和class属性，没有其他属性和标签，采用默认构造函数创建对象，如果对象中没有默认构造函数，对象无法创建。
            2.3.1.2 创建方式二： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器中）
            2.3.1.3 创建方式三： 使用工厂中的静态方法创建对象（某个类中静态方法创建对象，并存入spring容器)
        2.3.2 bean对象的作用范围： bean标签scope属性，用于指定bean的作用范围；
            2.3.2.1 singleton   单例 默认值
            2.3.2.2 prototype    多例
            2.3.2.3 request       作用于web的请求范围
            2.3.2.4 session      作用于web应用的会话范围
            2.3.2.5 global-session    作用于集群环境的会话范围（全局会话范围），当不是集群环境时，他就是session
        2.3.3 bean对象的生命周期：
            2.3.3.1 单例对象：
                出生：当容器创建时，对象出生
                活着：只要容器存在
                死亡：容器销毁
                总结：单例对象的生命周期和容器相同
            2.3.3.2 多例对象：
                出生：使用对象时
                活着：对象在使用过程中
                死亡： 当对象长时间不用且没有别的对象引用时，由java的垃圾回收器h回收

3. spring的依赖注入
    3.1 IOC的作用:降低程序间的的耦合（依赖关系）；
    3.2 依赖关系的管理：以后都交给spring来管理。当前类需要用到其他类的对象，由spring来提供，我们只需要在配置文件中说明。
    3.3 依赖关系的维护称之为：依赖注入
        3.3.1 依赖注入：
                能注入的数据：有三类
                    基本类型和String
                    其他bean类型（在配置文件中或者注解配置过的bean )
                    复杂类型/集合类型：
                              给List结构集合注入的标签有：
                                  list array set
                              用于给map结构注入的标签有：
                                  map props
                              结构相同，标签可以互换。
                注入的方式：
                    第一种：使用构造函数提供；
                                使用标签： constructor-arg
                                使用的位置： bean标签内部
                                标签中的属性：
                                    type: 用于指定要注入数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型
                                    index：用于指定要注入数据给构造函数中指定索引位置的参数赋值，参数的索引的位置从0开始
                                    name： 用于指定给构造函数中指定名称的参数赋值（常用）

                                    value： 用于提供基本类型和String类型数据
                                    ref:用于指定其他的bean类型数据，spring Ioc核心容器中出现过的对象
                                优势： 获取bean对象时，注入数据时必须操作，否则对象无法创建成功
                                弊端： 改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。
                    第二种：使用set方式提供：更常用
                                使用的标签：property
                                出现的位置：bean标签的内部
                                标签的属性：
                                    name： 用于指定注入时所调用的set方法名称
                                    value： 用于提供基本类型和String类型数据
                                    ref:用于指定其他的bean类型数据，spring Ioc核心容器中出现过的对象
                                好处： 创建对象时没有明确的限制，可以直接使用默认构造函数
                                弊端： 如果某个成员必须有值，则set方法无法保证一定注入。
                     第三种： 使用注解提供

4. spring基于注解的IoC
    4.1 spring中IoC的常用注解
        4.1.1 用于创建对象的注解：
            @Component: 用于把当前类对象存入spring容器中(配置Context）
            属性： value 用于指定bean的id,若不写，默认是当前类名，且首字母改小写

             @Controller: 用在表现层
             @Service： 一般用在业务层
             @Repository： 一般用在持久层
             以上的三个注解的作用和属性与@Component一样，他们是spring框架为我们提供明确的三层使用注解，使我们的三层对象更加清晰。

        4.1.2 用于注入数据的注解:
             @Autowired: 自动按照类型注入，容器中有唯一的bean对象类型和要注入的变量类型匹配，就可以注入成功
             如果ioc容器中没有一个bean类型和要注入的d的变量类型匹配，则报错。
             如果ioc容器中有多个类型匹配时：

             出现位置：可以是变量上，也可以是方法上
             在使用注解方法注入时，set方法不是必须的了


             @Qualifier: 在类型注入的基础上，再按照名称注入。他在给类成员注入时，不能单独使用，但在给方法参数注入时可以
             属性： value 用于指定注入bean的id

             @Resource: 直接按照bean的id注入，它可以单独使用，
             属性： name 用于指定注入bean的id
             以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用以上注解。另外集合类型的注入只能通过xml来实现。

             @Value: 用于基本类型和String类型的注入注解
             属性： value，用于指定数据的值，它可以使用spring中的SpEL(即spring中的el表达式）
                SpEL的写法： ${表达式}

        4.1.3 用于改变作用范围
              @Scope 用于指定bean的作用范围
              属性： 指定范围的取值，singleton prototype

        4.1.4 生命周期相关
              @Predestroy: 用于指定销毁方法
              @PostConstruct: 用于指定初始化方法
    4.2 案例： 使用xml方式实现单表的的CURD操作(持久层计数选择：dbutils）
        4.2.1 大致流程： 引入依赖（dependencies) -> 编写配置文件bean.xml -> 配置bean对象进spring IoC核心容器(bean set) -> 数据注入 -> 测试
    4.3 改造基于注解的IoC案例，使用纯注解的方式实现
        4.3.1 大致流程： 配置指定spring要扫描的包（context:componet-scan, 新注解@Confinguration 指定当前类为配置类， @ComponentScan:指定要扫描的包) -> 修改bean.xml文件，去掉可以用注解配置的语句（@Bean  @Scope @Service @Repository @Autowired) -> 测试
        4.3.2 细节： @Configuration 当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写
        4.3.3 @Import ： 导入其他配置类  value 用于指定其他配置类的字节码
        4.3.4 @PropertySource： 用于指定properties文件的路径   value: 指定文件的名称和路径  关键字：classpath  类路径下
    4.4 spring和junit的整合
        4.4.1 导入spring整合junit的jar包（坐标）
        4.4.2 使用junit提供的注解把原有的main方法替换掉，换成spring提供的： @RunWith
        4.4.3 告知spring的运行器，spring的ioc容器创建是基于xml还是注解，并且说明位置。@ContextConfiguration
            属性： locations --> xml文件的位置 + classpath 关键字，表示在类路径下
                   classes  ---> 表示注解类位置。
            注意版本的问题。
5. AOP: 面向切面编程
    5.1 AOP：全称是 Aspect Oriented Programming 即：面向切面编程，简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的
             基础上，对我们的已有方法进行增强。
    5.2 作用： 在程序运行期间，不修改源码对已有方法进行增强。
    5.3 优势：减少重复代码  提高开发效率  维护方便
    5.4 AOP 的实现方式： 使用动态代理技术
    5.5 动态代理回顾：
        5.5.1 特点：字节码随用随创建，随用随加载
        5.5.2 作用：不修改源码的情况下，对方法进行增强
        5.5.3 基于接口的动态代理：
                涉及的类：Proxy
               提供者： JDK官方
               如何创建代理对象： 使用Proxy 类中的newProxyInstance方法
               创建代理对象的要求：
                   被代理类至少实现一个接口，如果没有，无法使用
               newProxyInstance的参数：
                   ClassLoader: 类加载器
                       用于加载代理对象字节码，和被代理对象使用相同的类加载器。固定写法
                   Class[]:字节码数组
                       它是让代理对象和被代理对象有相同的方法，固定写法
                   InvocationHandler:用于提供增强的代码
                       它是让我们写如何代理，我们一般是写一些接口的实现类，通常情况下都是匿名内部类，但无必须。
                       此接口的实现类都是谁用，谁写。
        5.5.4 基于子类的动态代理
               涉及的类：Enhancer
               提供者：第三方cglib库
               如何创建代理对象： Enhancer create方法
               创建代理对象的要求：
                   被代理类不能是最终类。
               create的参数：
                   Class: 字节码
                       指定被代理对象的字节码。固定写法
                   Callback:用于提供增强的代码
                       它是让我们写如何代理，我们一般是写一些接口的实现类，通常情况下都是匿名内部类，但无必须。
                       此接口的实现类都是谁用，谁写。
                       我们一般写的是该接口的子接口实现类：MethodInterceptor
    5.6  Spring 中的 AOP
        5.6.1 AOP 相关术语:
            Joinpoint(连接点):所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。
            Pointcut(切入点):所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义
            Advice(通知/增强):所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知
            Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field
            Target(目标对象):代理的目标对象。
            Weaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程.(spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。)
            Proxy（代理）:一个类被 AOP 织入增强后，就产生一个结果代理类。
            Aspect(切面):是切入点和通知（引介）的结合

        5.6.2 基于 XML 的 AOP 配置:
            第一步：准备必要的代码
            第二步：拷贝必备的 jar 包到工程的 lib 目录
            第三步：创建spring 的配置文件并导入约束
            第四步：配置spring 的 ioc
            第五步：抽取公共代码制作成通知
                第一步：把通知类用 bean 标签配置起来
                第二步：使用 aop:config 声明 aop 配置
                第三步：使用 aop:aspect 配置切面
                第四步：使用 aop:pointcut 配置切入点表达式
                第五步：使用 aop:xxx 配置对应的通知类型

6. spring中的JdbcTemplate
	6.1 JdbcTemplate的作用： 用于和数据库的交互，实现对表的CURD操作
	6.2 如何创建该对象
	6.3 对象中常用的方法
	
7. spring中的事务控制
	7.1 基于XML
	7.2 基于注解的




